<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chrondle - The Daily History Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        h1, h2 {
            font-family: 'Playfair Display', serif;
        }

        .game-tile {
            transition: transform 0.3s ease, background-color 0.3s ease;
        }

        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s ease;
        }

        .modal-content {
            transition: transform 0.3s ease, opacity 0.3s ease;
            transform: scale(0.95);
            opacity: 0;
        }

        .modal-content.show {
            transform: scale(1);
            opacity: 1;
        }

        .guess-row {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Loading spinner animation */
        .spinner {
            border: 2px solid #e5e7eb;
            border-top: 2px solid #4f46e5;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }
        
        .dark .spinner {
            border-color: #374151;
            border-top-color: #818cf8;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Colorblind mode styles */
        html.color-blind .bg-red-200 { background-color: #fde047; /* yellow-400 */ }
        html.color-blind .text-red-800 { color: #854d0e; /* yellow-800 */ }
        html.color-blind .dark\:bg-red-800 { background-color: #facc15; /* yellow-500 */ }
        html.color-blind .dark\:text-red-100 { color: #422006; /* yellow-900 */ }
        html.color-blind .bg-blue-200 { background-color: #a5b4fc; /* indigo-300 */ }
        html.color-blind .text-blue-800 { color: #3730a3; /* indigo-800 */ }
        html.color-blind .dark\:bg-blue-800 { background-color: #6366f1; /* indigo-500 */ }
        html.color-blind .dark\:text-blue-100 { color: #e0e7ff; /* indigo-100 */ }

    </style>
    <script>
        // Tailwind dark mode configuration
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <script>
        const URL_PARAMS = new URLSearchParams(window.location.search);
        const DEBUG_MODE = URL_PARAMS.get('debug') === 'true';
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Main Game Container -->
    <div id="game-container" class="w-full max-w-2xl mx-auto">

        <!-- Header -->
        <header class="text-center mb-4 sm:mb-6">
            <h1 class="text-4xl sm:text-5xl font-bold tracking-wider">Chrondle</h1>
            <p class="text-gray-500 dark:text-gray-400 mt-1">Guess the year of the historical event.</p>
        </header>

        <!-- Debug Banner -->
        <div id="debug-banner" class="hidden bg-yellow-400 dark:bg-yellow-600 text-black p-2 text-center font-bold">
            🔧 DEBUG MODE ACTIVE - No progress saved | <span id="debug-params"></span>
        </div>

        <!-- Primary Event Display -->
        <div class="bg-white dark:bg-gray-800 shadow-lg rounded-xl p-6 mb-4 text-center min-h-[80px] flex items-center justify-center">
            <p class="text-lg sm:text-xl font-semibold" id="primary-event-text">
                <span class="spinner"></span>Loading today's historical puzzle...
            </p>
        </div>

        <!-- Guess Input -->
        <form id="guess-form" class="flex items-center gap-2 mb-4">
            <input type="number" id="guess-input" placeholder="Enter a year (e.g. 1969 AD or -776 for 776 BC)..." class="w-full p-3 text-lg bg-gray-200 dark:bg-gray-700 border-2 border-transparent focus:border-indigo-500 focus:ring-0 rounded-lg text-center" required disabled>
            <button type="submit" id="guess-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-200" disabled>
                Guess
            </button>
        </form>

        <!-- Guess History -->
        <div id="guess-history" class="space-y-3">
            <!-- Guess rows will be inserted here by JavaScript -->
        </div>
    </div>

    <!-- Settings and Help Icons -->
    <div class="absolute top-4 right-4 flex gap-3">
         <button id="help-button" class="text-gray-500 dark:text-gray-400 hover:text-indigo-600 dark:hover:text-indigo-400 transition">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
        </button>
        <button id="settings-button" class="text-gray-500 dark:text-gray-400 hover:text-indigo-600 dark:hover:text-indigo-400 transition">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
        </button>
    </div>

    <!-- How to Play Modal -->
    <div id="help-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-2xl max-w-md w-full p-6 modal-content">
            <h2 class="text-2xl font-bold mb-4 text-center">How to Play</h2>
            <div class="space-y-4 text-gray-600 dark:text-gray-300">
                <p>Guess the year of the historical event in 6 tries. Years can be BC or AD.</p>
                <p>After each guess, you'll receive two hints:</p>
                <ul class="list-disc list-inside space-y-2 pl-2">
                    <li>A directional hint: <span class="font-bold">▲ LATER</span> or <span class="font-bold">▼ EARLIER</span>.</li>
                    <li>A new historical event that happened in the <span class="font-bold">same target year</span>.</li>
                </ul>
                <p>Use the clues to narrow down your next guess and find the correct year!</p>
                <p class="text-sm bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg border-l-4 border-blue-400">
                    <span class="font-semibold">Daily Puzzle:</span> Everyone gets the same puzzle each day, so you can compare your results with friends!
                </p>
            </div>
            <button id="close-help-button" class="mt-6 w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition">Got it!</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-2xl max-w-md w-full p-6 modal-content">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold">Settings</h2>
                <button id="close-settings-button" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition">&times;</button>
            </div>
            <div class="space-y-4">
                <div class="flex items-center justify-between">
                    <label for="dark-mode-toggle" class="font-semibold">Dark Mode</label>
                    <button id="dark-mode-toggle" class="relative inline-flex items-center h-6 rounded-full w-11 transition-colors bg-gray-200 dark:bg-gray-600">
                        <span class="inline-block w-4 h-4 transform bg-white rounded-full transition-transform translate-x-1 dark:translate-x-6"></span>
                    </button>
                </div>
                <div class="flex items-center justify-between">
                    <label for="color-blind-toggle" class="font-semibold">Color-Blind Mode</label>
                    <button id="color-blind-toggle" class="relative inline-flex items-center h-6 rounded-full w-11 transition-colors bg-gray-200 dark:bg-gray-600">
                        <span class="inline-block w-4 h-4 transform bg-white rounded-full transition-transform translate-x-1 dark:translate-x-6"></span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-2xl max-w-md w-full p-6 text-center modal-content">
            <h2 id="game-over-title" class="text-3xl font-bold mb-2"></h2>
            <p class="text-lg mb-4">The correct year was <strong id="correct-year-text"></strong>.</p>

            <div id="final-events-list" class="text-left bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-4 max-h-48 overflow-y-auto">
                <h3 class="font-bold mb-2">Events from this year:</h3>
                <ul class="list-disc list-inside space-y-1">
                    <!-- Events will be populated here -->
                </ul>
            </div>

            <div id="share-block" class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg mb-4">
                <p class="font-mono text-center whitespace-pre-wrap" id="share-text"></p>
            </div>

            <div class="flex gap-4">
                <div class="flex-1 text-center">
                     <p class="text-gray-500 dark:text-gray-400 text-sm">NEXT CHRONDLE</p>
                     <p id="countdown-timer" class="text-2xl font-bold"></p>
                </div>
                <button id="share-button" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg transition-colors duration-200 flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12s-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.368a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z" /></svg>
                    Share
                </button>
            </div>
            <p id="copy-feedback" class="text-sm text-green-600 dark:text-green-400 h-5 mt-2"></p>
        </div>
    </div>


    <script>
    // --- API CONFIGURATION ---
    // Yes, this API key is exposed in client-side code. This is a prototype.
    // The API has rate limits (50k requests/month) and only provides historical data.
    // If someone steals this key to make historical event queries, that's their problem.
    const API_NINJAS_KEY = 'O8VgZplfhWSNdCsgoeVaZg==2bwPJnxstEQPzmvn';
    
    // Basic client-side rate limiting and caching
    const API_CACHE = new Map();
    let lastApiCall = 0;
    const MIN_API_INTERVAL = 1000; // 1 second between calls

    function canMakeApiCall() {
        const now = Date.now();
        return now - lastApiCall >= MIN_API_INTERVAL;
    }

    function updateLastApiCall() {
        lastApiCall = Date.now();
    }

    // --- API FUNCTIONS ---
    async function getHistoricalEvents(year) {
        // Input validation
        if (!year || typeof year !== 'number') {
            console.error('🔍 DEBUG: getHistoricalEvents: Invalid year parameter:', year);
            return [];
        }

        // Check cache first
        const cacheKey = `events-${year}`;
        if (API_CACHE.has(cacheKey)) {
            console.log(`🔍 DEBUG: Using cached events for year ${year}`);
            return API_CACHE.get(cacheKey);
        }

        // Rate limiting check
        if (!canMakeApiCall()) {
            console.warn('🔍 DEBUG: Rate limit: too soon since last API call');
            return [];
        }

        try {
            console.log(`🔍 DEBUG: Fetching historical events for year ${year}...`);
            updateLastApiCall();

            const apiUrl = `https://api.api-ninjas.com/v1/historicalevents?year=${year}`;
            console.log(`🔍 DEBUG: API URL: ${apiUrl}`);
            console.log(`🔍 DEBUG: API Key: ${API_NINJAS_KEY.substring(0, 10)}...`);

            const response = await fetch(apiUrl, {
                headers: {
                    'X-Api-Key': API_NINJAS_KEY
                }
            });

            console.log(`🔍 DEBUG: Response status: ${response.status} ${response.statusText}`);
            console.log(`🔍 DEBUG: Response headers:`, [...response.headers.entries()]);

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`🔍 DEBUG: API Error Response Body: ${errorText}`);
                throw new Error(`API response not OK: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const events = await response.json();
            console.log(`🔍 DEBUG: Raw API response:`, events);
            
            // Validate response
            if (!Array.isArray(events)) {
                console.error(`🔍 DEBUG: API response is not an array:`, typeof events, events);
                throw new Error('API response is not an array');
            }

            // Extract and clean event descriptions from API Ninjas
            const apiNinjasEvents = events.map(event => cleanEventDescription(event.event)).filter(Boolean);
            console.log(`🔍 DEBUG: API Ninjas returned ${apiNinjasEvents.length} events for year ${year}`);
            
            let finalEvents = apiNinjasEvents;
            
            // If we don't have enough events, try Wikidata SPARQL as backup
            if (finalEvents.length < 6) {
                console.log(`🔍 DEBUG: Insufficient events from API Ninjas (${finalEvents.length}), trying Wikidata SPARQL...`);
                
                try {
                    const wikidataEvents = await getWikidataEvents(year);
                    console.log(`🔍 DEBUG: Wikidata returned ${wikidataEvents.length} events for year ${year}`);
                    
                    if (wikidataEvents.length > 0) {
                        // Merge and deduplicate events
                        const mergedEvents = [...finalEvents];
                        
                        for (const wikidataEvent of wikidataEvents) {
                            // Check for duplicates (case-insensitive)
                            const isDuplicate = mergedEvents.some(existingEvent => 
                                existingEvent.toLowerCase().includes(wikidataEvent.toLowerCase().substring(0, 50)) ||
                                wikidataEvent.toLowerCase().includes(existingEvent.toLowerCase().substring(0, 50))
                            );
                            
                            if (!isDuplicate) {
                                mergedEvents.push(wikidataEvent);
                            }
                        }
                        
                        finalEvents = mergedEvents;
                        console.log(`🔍 DEBUG: After merging and deduplication: ${finalEvents.length} total events`);
                    }
                } catch (wikidataError) {
                    console.warn(`🔍 DEBUG: Wikidata SPARQL fallback failed for year ${year}:`, wikidataError.message);
                    // Continue with just API Ninjas events
                }
            }
            
            // Cache the final result
            API_CACHE.set(cacheKey, finalEvents);
            
            console.log(`🔍 DEBUG: Successfully fetched ${finalEvents.length} events for year ${year}:`, finalEvents);
            return finalEvents;

        } catch (error) {
            console.error(`🔍 DEBUG: Failed to fetch events for year ${year}:`, error);
            console.error(`🔍 DEBUG: Error details:`, {
                message: error.message,
                name: error.name,
                stack: error.stack
            });
            return [];
        }
    }

    // DEPRECATED: Wikipedia function kept as backup reference
    // Main flow now uses getWikidataEvents() for comprehensive historical coverage
    async function getWikipediaEvents(year, month, day) {
        // Input validation
        if (!year || typeof year !== 'number') {
            console.error('🔍 DEBUG: getWikipediaEvents: Invalid year parameter:', year);
            return [];
        }
        if (!month || !day || typeof month !== 'number' || typeof day !== 'number') {
            console.error('🔍 DEBUG: getWikipediaEvents: Invalid month/day parameters:', month, day);
            return [];
        }

        // Check cache first
        const cacheKey = `wikipedia-events-${year}-${month}-${day}`;
        if (API_CACHE.has(cacheKey)) {
            console.log(`🔍 DEBUG: Using cached Wikipedia events for year ${year}`);
            return API_CACHE.get(cacheKey);
        }

        // Rate limiting check
        if (!canMakeApiCall()) {
            console.warn('🔍 DEBUG: Rate limit: too soon since last API call');
            return [];
        }

        try {
            console.log(`🔍 DEBUG: Fetching Wikipedia events for ${month}/${day} filtering for year ${year}...`);
            updateLastApiCall();

            const apiUrl = `https://api.wikimedia.org/feed/v1/wikipedia/en/onthisday/events/${month}/${day}`;
            console.log(`🔍 DEBUG: Wikipedia API URL: ${apiUrl}`);

            const response = await fetch(apiUrl);

            console.log(`🔍 DEBUG: Wikipedia response status: ${response.status} ${response.statusText}`);

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`🔍 DEBUG: Wikipedia API Error Response Body: ${errorText}`);
                throw new Error(`Wikipedia API response not OK: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const data = await response.json();
            console.log(`🔍 DEBUG: Raw Wikipedia API response:`, data);
            
            // Validate response structure
            if (!data || !Array.isArray(data.events)) {
                console.error(`🔍 DEBUG: Wikipedia API response has invalid events structure:`, data);
                throw new Error('Wikipedia API response missing events array');
            }

            // Filter events for the target year and extract text descriptions
            const yearEvents = data.events
                .filter(event => event.year === year)
                .map(event => event.text)
                .filter(Boolean);

            // Cache the result
            API_CACHE.set(cacheKey, yearEvents);
            
            console.log(`🔍 DEBUG: Successfully fetched ${yearEvents.length} Wikipedia events for year ${year}:`, yearEvents);
            return yearEvents;

        } catch (error) {
            console.error(`🔍 DEBUG: Failed to fetch Wikipedia events for year ${year}:`, error);
            console.error(`🔍 DEBUG: Error details:`, {
                message: error.message,
                name: error.name,
                stack: error.stack
            });
            return [];
        }
    }

    // Clean Wikipedia metadata artifacts from event descriptions
    function cleanEventDescription(text) {
        if (!text || typeof text !== 'string') {
            return text;
        }
        
        try {
            // Remove Wikipedia citation and markup artifacts
            let cleaned = text
                // Remove citation needed variants
                .replace(/\[full citation needed\]/gi, '')
                .replace(/\[citation needed\]/gi, '')
                .replace(/\[better source needed\]/gi, '')
                .replace(/\[verification needed\]/gi, '')
                .replace(/\[clarification needed\]/gi, '')
                // Remove time-related markup
                .replace(/\[when\?\]/gi, '')
                .replace(/\[until when\?\]/gi, '')
                .replace(/\[since when\?\]/gi, '')
                // Remove other common Wikipedia markup
                .replace(/\[who\?\]/gi, '')
                .replace(/\[where\?\]/gi, '')
                .replace(/\[why\?\]/gi, '')
                .replace(/\[how\?\]/gi, '')
                .replace(/\[according to whom\?\]/gi, '')
                .replace(/\[says who\?\]/gi, '')
                // Remove extra whitespace and clean up
                .replace(/\s+/g, ' ')
                .trim();
            
            // Debug logging if cleaning made changes
            if (cleaned !== text) {
                console.log(`🔍 DEBUG: Cleaned Wikipedia markup: "${text}" → "${cleaned}"`);
            }
            
            return cleaned;
            
        } catch (error) {
            console.warn(`🔍 DEBUG: Failed to clean event description, using original:`, error);
            return text;
        }
    }

    // Enhance event descriptions using contextual data to create engaging game hints
    function enhanceEventDescription(label, description, location, participants) {
        if (!label || typeof label !== 'string') {
            return label;
        }
        
        try {
            // Clean inputs and prepare for processing
            const cleanLabel = label.trim();
            const cleanDescription = description ? description.trim() : '';
            const cleanLocation = location ? location.trim() : '';
            const cleanParticipants = participants ? participants.trim() : '';
            
            console.log(`🔍 DEBUG: Enhancing "${cleanLabel}" with context:`, {
                description: cleanDescription || 'none',
                location: cleanLocation || 'none',
                participants: cleanParticipants || 'none'
            });
            
            // Pattern matching for different event types
            let enhanced = '';
            
            // Battle enhancement rules
            if (cleanLabel.toLowerCase().includes('battle of') || 
                cleanDescription.toLowerCase().includes('battle')) {
                
                if (cleanLocation && cleanParticipants) {
                    enhanced = `Military conflict between ${cleanParticipants} in ${cleanLocation}`;
                } else if (cleanLocation) {
                    enhanced = `Military conflict in ${cleanLocation}`;
                } else if (cleanParticipants) {
                    enhanced = `Military conflict involving ${cleanParticipants}`;
                } else if (cleanDescription) {
                    enhanced = `Military conflict - ${cleanDescription.replace(/\d{4}/g, '')}`.trim();
                } else {
                    enhanced = `Military conflict`;
                }
            }
            
            // Treaty/Pact enhancement rules
            else if (cleanLabel.toLowerCase().includes('treaty') || 
                     cleanLabel.toLowerCase().includes('pact') ||
                     cleanDescription.toLowerCase().includes('treaty') ||
                     cleanDescription.toLowerCase().includes('union')) {
                
                if (cleanParticipants) {
                    enhanced = `Political agreement involving ${cleanParticipants}`;
                } else if (cleanDescription) {
                    enhanced = `Political agreement - ${cleanDescription.replace(/\d{4}/g, '')}`.trim();
                } else {
                    enhanced = `Political treaty or agreement`;
                }
            }
            
            // Cultural/Art enhancement rules  
            else if (cleanLabel.toLowerCase().includes('relief') ||
                     cleanLabel.toLowerCase().includes('sculpture') ||
                     cleanLabel.toLowerCase().includes('competition') ||
                     cleanLabel.toLowerCase().includes('artistic')) {
                
                if (cleanLocation) {
                    enhanced = `Artistic work or competition in ${cleanLocation}`;
                } else if (cleanDescription) {
                    enhanced = `Cultural event - ${cleanDescription.replace(/\d{4}/g, '')}`.trim();
                } else {
                    enhanced = `Artistic or cultural competition`;
                }
            }
            
            // Generic enhancement using description
            else if (cleanDescription) {
                // Use description but remove year references
                enhanced = cleanDescription.replace(/\d{4}/g, '').replace(/\s+/g, ' ').trim();
                if (cleanLocation) {
                    enhanced += ` in ${cleanLocation}`;
                }
            }
            
            // Fallback chain: enhanced > cleaned description > cleaned label
            const result = enhanced || cleanDescription || cleanLabel;
            
            // Final cleanup - remove years and extra whitespace
            const finalResult = result
                .replace(/\b\d{4}\b/g, '')  // Remove 4-digit years
                .replace(/\s+/g, ' ')       // Normalize whitespace
                .replace(/^[-\s]+|[-\s]+$/g, '') // Remove leading/trailing dashes and spaces
                .trim();
            
            if (finalResult !== cleanLabel) {
                console.log(`🔍 DEBUG: Enhanced "${cleanLabel}" → "${finalResult}"`);
            }
            
            return finalResult || cleanLabel; // Ultimate fallback to original label
            
        } catch (error) {
            console.warn(`🔍 DEBUG: Failed to enhance event description, using original:`, error);
            return label;
        }
    }

    // LLM enhancement for creating engaging game hints from enhanced descriptions
    async function llmEnhanceHint(enhancedDescription) {
        // Check if LLM enhancement is enabled
        const llmEnabled = URL_PARAMS.get('llm') === 'true';
        if (!llmEnabled) {
            return enhancedDescription; // Return original if LLM not enabled
        }
        
        // Check for API key (user must provide their own for security)
        const apiKey = localStorage.getItem('openai_api_key');
        if (!apiKey) {
            console.warn('🔍 DEBUG: LLM enhancement requested but no API key found. Set localStorage.openai_api_key to use LLM features.');
            return enhancedDescription;
        }
        
        try {
            // Rate limiting check
            const lastLlmCall = localStorage.getItem('last_llm_call');
            const now = Date.now();
            if (lastLlmCall && (now - parseInt(lastLlmCall)) < 2000) {
                console.log('🔍 DEBUG: LLM rate limit: too soon since last call');
                return enhancedDescription;
            }
            
            console.log(`🔍 DEBUG: Enhancing with LLM: "${enhancedDescription}"`);
            
            // Create abort controller for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);
            
            // Prepare LLM prompt
            const prompt = `Convert this historical event into a clear, engaging hint for a year-guessing game. Make it informative but don't include the year or obvious time markers. Keep it under 20 words: ${enhancedDescription}`;
            
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                signal: controller.signal,
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: [
                        {
                            role: 'system',
                            content: 'You are a helpful assistant that creates engaging, concise hints for historical guessing games.'
                        },
                        {
                            role: 'user',
                            content: prompt
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 50
                })
            });
            
            clearTimeout(timeoutId);
            localStorage.setItem('last_llm_call', now.toString());
            
            if (!response.ok) {
                const error = await response.text();
                console.warn(`🔍 DEBUG: LLM API error ${response.status}:`, error);
                return enhancedDescription;
            }
            
            const data = await response.json();
            const llmHint = data.choices[0].message.content.trim();
            
            console.log(`🔍 DEBUG: LLM enhanced "${enhancedDescription}" → "${llmHint}"`);
            return llmHint;
            
        } catch (error) {
            console.warn(`🔍 DEBUG: LLM enhancement failed, using fallback:`, error.message);
            return enhancedDescription;
        }
    }

    async function getWikidataEvents(year) {
        // Input validation
        if (!year || typeof year !== 'number') {
            console.error('🔍 DEBUG: getWikidataEvents: Invalid year parameter:', year);
            return [];
        }

        // Check cache first
        const cacheKey = `wikidata-events-${year}`;
        if (API_CACHE.has(cacheKey)) {
            console.log(`🔍 DEBUG: Using cached Wikidata events for year ${year}`);
            return API_CACHE.get(cacheKey);
        }

        // Note: No rate limiting for Wikidata SPARQL - different endpoint, no abuse risk
        try {
            console.log(`🔍 DEBUG: Fetching Wikidata events for year ${year}...`);

            // Enhanced SPARQL query: Get descriptions, locations, and participants for richer hints
            // Using automatic label service to get descriptions and context data
            const sparqlQuery = `
                SELECT ?event ?eventLabel ?eventDescription ?locationLabel ?participantLabel WHERE {
                    ?event wdt:P585 ?date .                  # Point in time
                    FILTER(YEAR(?date) = ${year})
                    {
                        ?event wdt:P31 wd:Q178561 .          # Battles
                    } UNION {
                        ?event wdt:P31 wd:Q131569 .          # Treaty
                    } UNION {
                        ?event wdt:P31 wd:Q1241715 .         # Abandoned village
                    } UNION {
                        ?event wdt:P31 wd:Q245117 .          # Relief sculpture
                    } UNION {
                        ?event wdt:P31 wd:Q12370 .           # Peace treaty
                    }
                    OPTIONAL { ?event wdt:P276 ?location }   # Location
                    OPTIONAL { ?event wdt:P710 ?participant } # Participant
                    SERVICE wikibase:label { 
                        bd:serviceParam wikibase:language "en" . 
                    }
                } LIMIT 25
            `;

            const apiUrl = `https://query.wikidata.org/sparql?query=${encodeURIComponent(sparqlQuery)}`;
            console.log(`🔍 DEBUG: Wikidata SPARQL URL: ${apiUrl.substring(0, 100)}...`);

            // Create abort controller for timeout handling
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

            const response = await fetch(apiUrl, {
                headers: {
                    'Accept': 'application/sparql-results+json'
                },
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            console.log(`🔍 DEBUG: Wikidata response status: ${response.status} ${response.statusText}`);

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`🔍 DEBUG: Wikidata SPARQL Error Response Body: ${errorText}`);
                throw new Error(`Wikidata SPARQL response not OK: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const data = await response.json();
            console.log(`🔍 DEBUG: Raw Wikidata SPARQL response:`, data);
            
            // Validate response structure
            if (!data || !data.results || !Array.isArray(data.results.bindings)) {
                console.error(`🔍 DEBUG: Wikidata SPARQL response has invalid structure:`, data);
                throw new Error('Wikidata SPARQL response missing results.bindings array');
            }

            // Extract enhanced event data from targeted entity types
            const yearEvents = data.results.bindings
                .map(item => {
                    const label = item.eventLabel && item.eventLabel.value;
                    const description = item.eventDescription && item.eventDescription.value;
                    const location = item.locationLabel && item.locationLabel.value;
                    const participant = item.participantLabel && item.participantLabel.value;
                    
                    if (label) {
                        console.log(`🔍 DEBUG: Enhanced data for "${label}":`, {
                            description: description || 'none',
                            location: location || 'none', 
                            participant: participant || 'none'
                        });
                        
                        // Enhance the event using all available contextual data
                        return enhanceEventDescription(label, description, location, participant);
                    }
                    return null;
                })
                .filter(Boolean)
                .slice(0, 20); // Limit to 20 events maximum

            // Cache the result
            API_CACHE.set(cacheKey, yearEvents);
            
            console.log(`🔍 DEBUG: Successfully fetched ${yearEvents.length} Wikidata events for year ${year}:`, yearEvents);
            return yearEvents;

        } catch (error) {
            console.error(`🔍 DEBUG: Failed to fetch Wikidata events for year ${year}:`, error);
            
            // Log specific error types
            if (error.name === 'AbortError') {
                console.error(`🔍 DEBUG: Wikidata SPARQL query timeout for year ${year}`);
            } else if (error.message.includes('NetworkError')) {
                console.error(`🔍 DEBUG: Network error accessing Wikidata for year ${year}`);
            } else if (error.message.includes('SyntaxError')) {
                console.error(`🔍 DEBUG: SPARQL parsing error for year ${year}`);
            }
            
            console.error(`🔍 DEBUG: Error details:`, {
                message: error.message,
                name: error.name,
                stack: error.stack
            });
            return [];
        }
    }

    // --- PUZZLE CONFIGURATION ---
    // Curated years known to have significant historical events
    // Selected for variety across eras and likelihood of having 6+ events from API
    const CURATED_YEARS = [
        // Ancient/Classical Era
        -776, -753, -221, -44,  // BC years (negative)
        
        // Medieval Era
        800, 1066, 1215, 1347, 1453,
        
        // Renaissance/Early Modern
        1492, 1517, 1588, 1607, 1620,
        
        // Enlightenment/Revolution Era
        1776, 1789, 1804, 1815, 1848,
        
        // Industrial Age
        1865, 1876, 1885, 1893, 1903,
        
        // Early 20th Century
        1914, 1917, 1918, 1929, 1936,
        
        // WWII Era
        1939, 1941, 1945, 1947, 1948,
        
        // Cold War Era
        1957, 1961, 1963, 1969, 1975,
        
        // Late 20th Century
        1989, 1991, 1994, 1997, 1999,
        
        // 21st Century
        2001, 2003, 2008, 2011, 2016, 2020
    ];

    // Fallback year when API fails or returns insufficient events
    // 1969 chosen for reliable event count: Moon landing, Woodstock, Vietnam War events
    const FALLBACK_YEAR = 1969;

    // --- DAILY PUZZLE LOGIC ---
    function getDailyYear() {
        const forcedYear = URL_PARAMS.get('year');
        if (forcedYear && DEBUG_MODE) {
            const parsedYear = parseInt(forcedYear, 10);
            if (!isNaN(parsedYear) && parsedYear >= -3000 && parsedYear <= new Date().getFullYear()) {
                console.log(`Debug: forcing year to ${parsedYear}`);
                return parsedYear;
            }
            console.warn(`Debug: Invalid year parameter '${forcedYear}' ignored`);
        }
        const today = new Date();
        
        // DEBUG: Log the raw date before modification
        console.log(`🔍 DEBUG: Raw today date: ${today.toISOString()}`);
        console.log(`🔍 DEBUG: Today's date string: ${today.toISOString().slice(0, 10)}`);
        
        // Reset time to midnight to ensure consistency across timezones
        today.setHours(0, 0, 0, 0);
        
        // Use hash of date for unpredictable but deterministic selection
        const yearIndex = Math.abs([...today.toISOString().slice(0,10)].reduce((a,b)=>(a<<5)+a+b.charCodeAt(),5381)) % CURATED_YEARS.length;
        const selectedYear = CURATED_YEARS[yearIndex];
        
        console.log(`🔍 DEBUG: Date: ${today.toISOString().slice(0,10)}, Year index: ${yearIndex}, Selected year: ${selectedYear}`);
        
        return selectedYear;
    }

    async function initializePuzzle() {
        console.log('🔍 DEBUG: Initializing daily puzzle...');
        
        try {
            // Get the daily year
            const targetYear = getDailyYear();
            console.log(`🔍 DEBUG: Target year for today: ${targetYear}`);
            
            // Fetch events for the target year
            let events = await getHistoricalEvents(targetYear);
            let usedYear = targetYear;
            
            console.log(`🔍 DEBUG: Fetched ${events ? events.length : 0} events for year ${targetYear}`);
            
            // Check if we have enough events (need 6 for the game)
            if (!events || events.length < 6) {
                console.warn(`🔍 DEBUG: Insufficient events for year ${targetYear} (${events ? events.length : 0} events), using fallback year ${FALLBACK_YEAR}`);
                
                // Try fallback year
                events = await getHistoricalEvents(FALLBACK_YEAR);
                usedYear = FALLBACK_YEAR;
                
                console.log(`🔍 DEBUG: Fallback year ${FALLBACK_YEAR} returned ${events ? events.length : 0} events`);
                
                // If fallback also fails, use hardcoded events
                if (!events || events.length < 6) {
                    console.error('🔍 DEBUG: API completely failed, using hardcoded events');
                    events = [
                        'The Boeing 747 makes its first flight',
                        'The Internet precursor ARPANET is created',
                        'The Stonewall riots occur in New York',
                        'Richard Nixon becomes President',
                        'Woodstock music festival takes place',
                        'Apollo 11 lands on the Moon'
                    ];
                    usedYear = FALLBACK_YEAR;
                    console.log(`🔍 DEBUG: Using hardcoded events for year ${usedYear}`);
                }
            } else {
                console.log(`🔍 DEBUG: Successfully got ${events.length} events for year ${targetYear}`);
            }
            
            // Sort events by recognizability (most obscure first, easiest last)
            const sortedEvents = sortEventsByRecognizability(events);
            console.log(`Sorted ${sortedEvents.length} events by difficulty (obscure to obvious) for year ${usedYear}`);
            
            // Generate simple puzzle ID for today (just the date)
            const today = new Date();
            const dateString = today.toISOString().slice(0, 10); // YYYY-MM-DD
            
            // Create puzzle object
            const puzzle = {
                year: usedYear,
                events: sortedEvents.slice(0, 6), // Use sorted events, ensure exactly 6
                puzzleId: dateString
            };
            
            console.log(`Puzzle initialized successfully:`, puzzle);
            return puzzle;
            
        } catch (error) {
            console.error('Failed to initialize puzzle:', error);
            
            // Last resort: return hardcoded puzzle
            const today = new Date();
            const dateString = today.toISOString().slice(0, 10); // YYYY-MM-DD
            
            return {
                year: FALLBACK_YEAR,
                events: [
                    'The Boeing 747 makes its first flight',
                    'The Internet precursor ARPANET is created',
                    'The Stonewall riots occur in New York',
                    'Richard Nixon becomes President',
                    'Woodstock music festival takes place',
                    'Apollo 11 lands on the Moon'
                ],
                puzzleId: dateString
            };
        }
    }

    // --- EVENT SORTING FUNCTIONS ---
    function scoreEventRecognizability(event) {
        const text = event.toLowerCase();
        let score = 0;
        
        // High-recognition keywords (famous events, people, places)
        const highRecognitionTerms = [
            'moon', 'apollo', 'nasa', 'president', 'war', 'peace', 'treaty', 'independence',
            'revolution', 'atomic', 'bomb', 'hitler', 'stalin', 'churchill', 'roosevelt',
            'kennedy', 'lincoln', 'washington', 'napoleon', 'caesar', 'rome', 'paris',
            'london', 'america', 'united states', 'world war', 'olympics', 'pearl harbor',
            'berlin wall', 'cold war', 'vietnam', 'titanic', 'earthquake', 'discovery',
            'invention', 'first', 'assassinated', 'founded', 'empire', 'king', 'queen'
        ];
        
        // Medium-recognition keywords
        const mediumRecognitionTerms = [
            'battle', 'siege', 'died', 'born', 'elected', 'crowned', 'signed', 'declared',
            'defeated', 'conquered', 'expedition', 'voyage', 'constructed', 'completed',
            'university', 'cathedral', 'castle', 'city', 'established', 'created'
        ];
        
        // Count high-recognition terms (worth 10 points each)
        highRecognitionTerms.forEach(term => {
            if (text.includes(term)) score += 10;
        });
        
        // Count medium-recognition terms (worth 5 points each)
        mediumRecognitionTerms.forEach(term => {
            if (text.includes(term)) score += 5;
        });
        
        // Bonus for shorter events (more concise = more recognizable)
        if (text.length < 50) score += 5;
        if (text.length < 30) score += 5;
        
        // Penalty for very long events (likely too detailed/obscure)
        if (text.length > 100) score -= 5;
        
        return score;
    }

    function sortEventsByRecognizability(events) {
        // Create array of events with their scores
        const scoredEvents = events.map(event => ({
            event: event,
            score: scoreEventRecognizability(event)
        }));
        
        // Sort by score (lowest first = most obscure first), then by length (longer first) as tiebreaker
        scoredEvents.sort((a, b) => {
            if (a.score !== b.score) {
                return a.score - b.score; // Ascending = lowest scores first (most obscure)
            }
            return b.event.length - a.event.length; // Longer events first as tiebreaker
        });
        
        // Return just the sorted events
        return scoredEvents.map(item => item.event);
    }

    document.addEventListener('DOMContentLoaded', () => {

        // --- DOM ELEMENTS ---
        const guessForm = document.getElementById('guess-form');
        const guessInput = document.getElementById('guess-input');
        const guessButton = document.getElementById('guess-button');
        const guessHistory = document.getElementById('guess-history');
        const primaryEventText = document.getElementById('primary-event-text');

        const helpButton = document.getElementById('help-button');
        const helpModal = document.getElementById('help-modal');
        const closeHelpButton = document.getElementById('close-help-button');

        const settingsButton = document.getElementById('settings-button');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsButton = document.getElementById('close-settings-button');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const colorBlindToggle = document.getElementById('color-blind-toggle');

        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverTitle = document.getElementById('game-over-title');
        const correctYearText = document.getElementById('correct-year-text');
        const finalEventsList = document.getElementById('final-events-list').querySelector('ul');
        const shareText = document.getElementById('share-text');
        const shareButton = document.getElementById('share-button');
        const copyFeedback = document.getElementById('copy-feedback');
        const countdownTimer = document.getElementById('countdown-timer');


        // --- GAME STATE ---
        let gameState = {
            puzzle: null,
            guesses: [],
            maxGuesses: 6,
            isGameOver: false,
        };

        // Add global debugging functions (always available, not just in debug mode)
        window.chrondle = {
            reset: () => location.reload(),
            state: () => console.log(gameState),
            clearStorage: () => { 
                const keys = Object.keys(localStorage).filter(k => k.startsWith('chrondle-'));
                keys.forEach(k => localStorage.removeItem(k)); 
                console.log(`🗑️ Cleared ${keys.length} chrondle storage entries:`, keys); 
                return keys;
            },
            setYear: (year) => { gameState.puzzle.year = year; console.log(`Forced year to ${year}`); },
            testYear: (year) => {
                const url = new URL(window.location);
                url.searchParams.set('debug', 'true');
                url.searchParams.set('year', year);
                window.location.href = url.toString();
            },
            debug: () => {
                console.log('🔍 Current date:', new Date().toISOString());
                console.log('🔍 Storage key:', getStorageKey());
                console.log('🔍 Game state:', gameState);
                const allChrondles = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('chrondle-')) {
                        allChrondles.push({key, value: localStorage.getItem(key)});
                    }
                }
                console.log('🔍 All chrondle localStorage:', allChrondles);
            }
        };

        if (DEBUG_MODE) {
            console.log('🔧 Debug mode active. Use window.chrondle for utilities.');
        } else {
            console.log('🔧 Debug utilities available: window.chrondle.debug(), window.chrondle.clearStorage()');
        }

        // --- INITIALIZATION ---
        async function init() {
            loadSettings();
            cleanupOldStorage(); // Remove old localStorage entries

            try {
                // Fetch puzzle from API
                gameState.puzzle = await initializePuzzle();

                if (DEBUG_MODE) {
                    const scenario = URL_PARAMS.get('scenario');
                    if (scenario === '6wrong') {
                        // Pre-load 5 wrong guesses, ready for 6th guess testing
                        const wrongGuesses = [1500, 1800, 1900, 1950, 2000];
                        wrongGuesses.forEach(guess => {
                            if (gameState.guesses.length < 5) {
                                gameState.guesses.push(guess);
                                renderGuess(guess, gameState.guesses.length - 1);
                            }
                        });
                        console.log('🎯 Scenario: 5 wrong guesses loaded, ready for 6th guess test');
                    }
                    
                    // Show debug banner and populate parameters
                    const banner = document.getElementById('debug-banner');
                    const params = document.getElementById('debug-params');
                    banner.classList.remove('hidden');
                    const activeParams = [];
                    if (URL_PARAMS.get('year')) activeParams.push(`year=${URL_PARAMS.get('year')}`);
                    if (URL_PARAMS.get('scenario')) activeParams.push(`scenario=${URL_PARAMS.get('scenario')}`);
                    params.textContent = activeParams.length ? activeParams.join(' | ') : 'Basic debug mode';
                }

                // Enable inputs now that puzzle is loaded
                guessInput.disabled = false;
                guessButton.disabled = false;

                loadProgress();
                setupUI();

                if (!localStorage.getItem('chrondle-has-played')) {
                    showModal(helpModal);
                }
            } catch (error) {
                // Handle errors
                console.error('Error during initialization:', error);
                primaryEventText.innerHTML = `
                    <div class="text-red-600 dark:text-red-400">
                        <h3 class="text-xl font-bold mb-2">Unable to Load Puzzle</h3>
                        <p>Please refresh the page to try again.</p>
                    </div>
                `;

                // Keep inputs disabled when there's an error
                guessInput.disabled = true;
                guessButton.disabled = true;
            }
        }




        function setupUI() {
            primaryEventText.textContent = gameState.puzzle.events[0];
            guessHistory.innerHTML = '';
            gameState.guesses.forEach((guess, index) => renderGuess(guess, index));
            updateGuessButton();

            if (gameState.isGameOver) {
                showGameOver();
            }
        }

        // --- GAME LOGIC ---

        function handleGuess(e) {
            e.preventDefault();
            if (gameState.isGameOver) return;

            const guess = parseInt(guessInput.value, 10);
            if (isNaN(guess) || guess < -3000 || guess > new Date().getFullYear() || guess === 0) {
                // simple validation. Using a custom modal/toast would be better than alert.
                // For this example, we'll keep it simple.
                 copyFeedback.textContent = 'Please enter a valid year.';
                 setTimeout(() => copyFeedback.textContent = '', 2000);
                return;
            }

            gameState.guesses.push(guess);
            renderGuess(guess);
            saveProgress();

            const isCorrect = (guess === gameState.puzzle.year);
            const isLastGuess = (gameState.guesses.length >= gameState.maxGuesses);

            if (isCorrect || isLastGuess) {
                gameState.isGameOver = true;
                saveProgress();
                // Delay showing the game over screen to allow the last guess animation to play
                setTimeout(() => showGameOver(isCorrect), 500);
            }

            guessInput.value = '';
            guessInput.focus();
            updateGuessButton();
        }

        function updateGuessButton() {
            const remaining = gameState.maxGuesses - gameState.guesses.length;
            guessButton.textContent = `Guess (${remaining}/${gameState.maxGuesses})`;
            if(remaining <= 0 || gameState.isGameOver) {
                guessButton.disabled = true;
                guessInput.disabled = true;
                guessButton.classList.add('opacity-50', 'cursor-not-allowed');
                guessInput.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        function showGameOver(isWin = false) {
             if (gameState.guesses.length > 0 && !gameState.guesses.includes(gameState.puzzle.year)) {
                 isWin = false;
             } else if (gameState.guesses.includes(gameState.puzzle.year)) {
                 isWin = true;
             }

            gameOverTitle.textContent = isWin ? "You got it!" : "So close!";
            correctYearText.textContent = formatYear(gameState.puzzle.year);

            finalEventsList.innerHTML = '';
            gameState.puzzle.events.forEach(event => {
                const li = document.createElement('li');
                li.textContent = event;
                finalEventsList.appendChild(li);
            });

            generateShareText();
            startCountdown();
            showModal(gameOverModal);
        }

        // --- RENDERING ---

        function renderGuess(guess, index = null) {
            // Use provided index or calculate for new guess
            const guessIndex = index !== null ? index : gameState.guesses.length - 1;
            const { year, events } = gameState.puzzle;

            const directionInfo = getGuessDirectionInfo(guess, year);
            const hintText = events[guessIndex + 1] || 'No more hints available.';

            let rowHTML;

            if (guess === year) {
                rowHTML = `
                    <div class="guess-row bg-green-500 text-white p-4 rounded-lg flex items-center justify-between shadow-md">
                        <span class="font-bold text-lg">${formatYear(guess)}</span>
                        <span class="font-bold text-lg">CORRECT!</span>
                    </div>
                `;
            } else {
                 rowHTML = `
                    <div class="guess-row bg-white dark:bg-gray-800 p-4 rounded-lg flex flex-col sm:flex-row items-start sm:items-center gap-4 shadow-md">
                        <div class="flex items-center gap-3 w-full sm:w-auto">
                           <div class="flex-shrink-0 text-center font-bold text-sm p-2 rounded-md min-w-32 ${directionInfo.bgColor} ${directionInfo.textColor}">${directionInfo.direction}</div>
                           <div class="flex flex-col items-center">
                               <div class="font-bold text-xl">${formatYear(guess)}</div>
                           </div>
                        </div>
                        <div class="border-l-2 border-gray-200 dark:border-gray-600 pl-4 text-gray-600 dark:text-gray-300 flex-1">
                           <span class="font-semibold text-gray-500 dark:text-gray-400">Hint:</span> ${hintText || 'No more hints available.'}
                        </div>
                    </div>
                `;
            }

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = rowHTML.trim();
            const guessRowElement = tempDiv.firstChild;
            guessRowElement.style.animationDelay = `${(gameState.guesses.length-1) * 100}ms`;
            guessHistory.appendChild(guessRowElement);
        }

        // --- UTILITIES & HELPERS ---

        function formatYear(year) {
            if (year < 0) {
                return `${Math.abs(year)} BC`;
            } else {
                return `${year} AD`;
            }
        }

        function getProximityFeedback(guess, target) {
            const difference = Math.abs(guess - target);
            
            if (difference === 0) {
                return { message: 'CORRECT!', class: 'text-green-600 dark:text-green-400' };
            } else if (difference <= 5) {
                return { message: 'Within 5 years!', class: 'text-green-500 dark:text-green-400' };
            } else if (difference <= 10) {
                return { message: 'Within 10 years!', class: 'text-lime-500 dark:text-lime-400' };
            } else if (difference <= 25) {
                return { message: 'Within 25 years!', class: 'text-yellow-500 dark:text-yellow-400' };
            } else if (difference <= 50) {
                return { message: 'Within 50 years!', class: 'text-orange-500 dark:text-orange-400' };
            } else if (difference <= 100) {
                return { message: 'Within a century!', class: 'text-red-400 dark:text-red-400' };
            } else if (difference <= 250) {
                return { message: 'Within 250 years!', class: 'text-red-500 dark:text-red-500' };
            } else if (difference <= 500) {
                return { message: 'Within 500 years!', class: 'text-red-600 dark:text-red-600' };
            } else if (difference <= 1000) {
                return { message: 'Within a millennium!', class: 'text-red-700 dark:text-red-700' };
            } else {
                return { message: `${Math.round(difference/1000)}+ millennia off`, class: 'text-gray-500 dark:text-gray-400' };
            }
        }


        function getGuessDirectionInfo(guess, target) {
            const isEarlier = guess < target;
            const direction = isEarlier ? '▲ LATER' : '▼ EARLIER';
            
            return {
                direction: direction,
                bgColor: isEarlier ? 'bg-red-200 dark:bg-red-800' : 'bg-blue-200 dark:bg-blue-800',
                textColor: isEarlier ? 'text-red-800 dark:text-red-100' : 'text-blue-800 dark:text-blue-100'
            };
        }


        function generateShareText() {
            const isWin = gameState.guesses.includes(gameState.puzzle.year);
            const today = new Date();
            const dateStr = today.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            
            // Create header with readable date and result
            const result = isWin ? `${gameState.guesses.length}/6 ⭐` : `X/6 💥`;
            let shareContent = `Chrondle - ${dateStr}\n`;
            shareContent += `Target: ${formatYear(gameState.puzzle.year)} - ${result}\n\n`;
            
            // Add detailed guess information
            shareContent += 'My guesses:\n';
            gameState.guesses.forEach((guess, index) => {
                const proximity = getProximityFeedback(guess, gameState.puzzle.year);
                let guessEmoji;
                
                if (guess === gameState.puzzle.year) {
                    guessEmoji = '🟩'; // Correct
                } else if (guess < gameState.puzzle.year) {
                    guessEmoji = '🔼'; // Too early, need later
                } else {
                    guessEmoji = '🔽'; // Too late, need earlier
                }
                
                shareContent += `${index + 1}. ${formatYear(guess)} ${guessEmoji} ${proximity.message}\n`;
            });
            
            shareContent += '\n#Chrondle #HistoryGame';
            shareText.textContent = shareContent;
        }

        function startCountdown() {
            const interval = setInterval(() => {
                const now = new Date();
                const midnight = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 0);
                const diff = midnight - now;

                if (diff <= 0) {
                    countdownTimer.textContent = "00:00:00";
                    clearInterval(interval);
                    return;
                }

                const hours = Math.floor(diff / (1000 * 60 * 60)).toString().padStart(2, '0');
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60)).toString().padStart(2, '0');
                const seconds = Math.floor((diff % (1000 * 60)) / 1000).toString().padStart(2, '0');

                countdownTimer.textContent = `${hours}:${minutes}:${seconds}`;
            }, 1000);
        }

        function showModal(modal) {
            modal.classList.remove('hidden');
            setTimeout(() => modal.firstElementChild.classList.add('show'), 10);
        }

        function hideModal(modal) {
            modal.firstElementChild.classList.remove('show');
            setTimeout(() => modal.classList.add('hidden'), 300);
        }

        // --- LOCAL STORAGE ---

        function getStorageKey() {
             const today = new Date();
             const dateString = today.toISOString().slice(0, 10); // YYYY-MM-DD
             const storageKey = `chrondle-progress-${dateString}`;
             console.log(`🔍 DEBUG: Storage key generated: ${storageKey}`);
            return storageKey;
        }

        function saveProgress() {
            if (DEBUG_MODE) { console.log('Debug mode: skipping localStorage save'); return; }
            const progress = {
                guesses: gameState.guesses,
                isGameOver: gameState.isGameOver,
                puzzleId: gameState.puzzle ? gameState.puzzle.puzzleId : null,
                puzzleYear: gameState.puzzle ? gameState.puzzle.year : null,
                timestamp: new Date().toISOString()
            };
            console.log(`🔍 DEBUG: Saving progress:`, progress);
            localStorage.setItem(getStorageKey(), JSON.stringify(progress));
        }

        function loadProgress() {
            if (DEBUG_MODE) { console.log('Debug mode: skipping localStorage load'); return null; }
            const storageKey = getStorageKey();
            const savedProgress = localStorage.getItem(storageKey);
            console.log(`🔍 DEBUG: Loading progress for key: ${storageKey}`);
            console.log(`🔍 DEBUG: Found saved progress:`, savedProgress);
            
            // DEBUG: Log all chrondle keys in localStorage
            const allChrondles = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('chrondle-')) {
                    allChrondles.push({key, value: localStorage.getItem(key)});
                }
            }
            console.log(`🔍 DEBUG: All chrondle localStorage entries:`, allChrondles);
            
            if (savedProgress) {
                const progress = JSON.parse(savedProgress);
                console.log(`🔍 DEBUG: Parsed progress:`, progress);
                
                // Validate that the saved progress matches the current puzzle
                const currentPuzzleId = gameState.puzzle ? gameState.puzzle.puzzleId : null;
                const currentPuzzleYear = gameState.puzzle ? gameState.puzzle.year : null;
                
                console.log(`🔍 DEBUG: Current puzzle - ID: ${currentPuzzleId}, Year: ${currentPuzzleYear}`);
                console.log(`🔍 DEBUG: Saved puzzle - ID: ${progress.puzzleId}, Year: ${progress.puzzleYear}`);
                
                // Check if this progress belongs to the current puzzle
                const isValidProgress = progress.puzzleId === currentPuzzleId && 
                                      progress.puzzleYear === currentPuzzleYear;
                
                if (isValidProgress) {
                    console.log(`🔍 DEBUG: Progress is valid for current puzzle`);
                    gameState.guesses = progress.guesses || [];
                    gameState.isGameOver = progress.isGameOver || false;
                    console.log(`🔍 DEBUG: Loaded ${gameState.guesses.length} guesses, game over: ${gameState.isGameOver}`);
                } else {
                    console.log(`🔍 DEBUG: Progress is invalid for current puzzle - clearing old progress`);
                    // Clear the invalid progress
                    localStorage.removeItem(storageKey);
                    // Reset game state to fresh start
                    gameState.guesses = [];
                    gameState.isGameOver = false;
                }
            } else {
                console.log(`🔍 DEBUG: No saved progress found for today`);
            }
        }

        function saveSettings() {
             localStorage.setItem('chrondle-settings', JSON.stringify({
                darkMode: document.documentElement.classList.contains('dark'),
                colorBlindMode: document.documentElement.classList.contains('color-blind'),
            }));
        }

        function cleanupOldStorage() {
            const today = new Date().toISOString().slice(0, 10);
            const todayKey = `chrondle-progress-${today}`;
            
            console.log(`🔍 DEBUG: Cleaning up old localStorage entries, keeping: ${todayKey}`);
            
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('chrondle-progress-') && key !== todayKey) {
                    keysToRemove.push(key);
                }
            }
            
            keysToRemove.forEach(key => {
                localStorage.removeItem(key);
                console.log(`🗑️ Removed old storage entry: ${key}`);
            });
            
            if (keysToRemove.length > 0) {
                console.log(`🔍 DEBUG: Cleaned up ${keysToRemove.length} old entries`);
            }
        }

        function loadSettings() {
            const settings = JSON.parse(localStorage.getItem('chrondle-settings'));
            if (settings) {
                if(settings.darkMode) {
                    document.documentElement.classList.add('dark');
                    darkModeToggle.querySelector('span').classList.add('dark:translate-x-6');
                }
                if(settings.colorBlindMode) {
                    document.documentElement.classList.add('color-blind');
                    colorBlindToggle.querySelector('span').classList.add('dark:translate-x-6');
                }
            }
        }

        // --- EVENT LISTENERS ---
        guessForm.addEventListener('submit', handleGuess);

        helpButton.addEventListener('click', () => showModal(helpModal));
        closeHelpButton.addEventListener('click', () => {
            hideModal(helpModal);
            localStorage.setItem('chrondle-has-played', 'true');
        });

        settingsButton.addEventListener('click', () => showModal(settingsModal));
        closeSettingsButton.addEventListener('click', () => hideModal(settingsModal));

        darkModeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            darkModeToggle.querySelector('span').classList.toggle('dark:translate-x-6');
            saveSettings();
        });

        colorBlindToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('color-blind');
            colorBlindToggle.querySelector('span').classList.toggle('dark:translate-x-6');
            saveSettings();
        });

        shareButton.addEventListener('click', () => {
            const textarea = document.createElement('textarea');
            textarea.value = shareText.textContent;
            textarea.style.position = 'fixed';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                copyFeedback.textContent = 'Copied to clipboard!';
                setTimeout(() => copyFeedback.textContent = '', 2000);
            } catch (err) {
                copyFeedback.textContent = 'Failed to copy!';
                console.error('Fallback: Oops, unable to copy', err);
            }
            document.body.removeChild(textarea);
        });

        [helpModal, settingsModal, gameOverModal].forEach(modal => {
            modal.addEventListener('click', (e) => {
                if(e.target === modal) hideModal(modal);
            });
        });

        if (DEBUG_MODE) {
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'r': e.preventDefault(); location.reload(); break;
                        case 'c': e.preventDefault(); window.chrondle.clearStorage(); location.reload(); break;
                        case 'd': e.preventDefault(); window.chrondle.state(); break;
                    }
                }
            });
            console.log('⌨️  Debug shortcuts: Ctrl+R (reset), Ctrl+C (clear storage), Ctrl+D (dump state)');
        }

        // --- START THE GAME ---
        init();
    });
    </script>

</body>
</html>

