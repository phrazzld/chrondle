import { DatabaseWriter } from "../_generated/server";
import { Id } from "../_generated/dataModel";
import { calculateStreakUpdate, applyStreakUpdate, getUTCDateString } from "./streakCalculation";
import { classifyPuzzle, isDailyPuzzle } from "./puzzleType";

/**
 * Streak Helpers - Database Operations for User Streaks
 *
 * Module: Shared database helpers for streak management
 * Location: convex/lib/ (not code-generated by Convex)
 *
 * CRITICAL BUSINESS RULE: Only updates streak for TODAY'S daily puzzle.
 * Archive/historical puzzle plays MUST NOT affect daily streak mechanics.
 *
 * Dependencies:
 * - streakCalculation: Pure functions for streak state management
 */

/**
 * Update user streak after completing a puzzle
 *
 * CRITICAL: Only updates streak for today's daily puzzle to prevent
 * archive/historical puzzle plays from affecting daily streak mechanics.
 *
 * @param ctx - Database writer context
 * @param userId - User ID to update
 * @param hasWon - Whether the user won the puzzle
 * @param puzzleDate - ISO date string (YYYY-MM-DD) of the puzzle being played
 */
export async function updateUserStreak(
  ctx: { db: DatabaseWriter },
  userId: Id<"users">,
  hasWon: boolean,
  puzzleDate: string,
) {
  const user = await ctx.db.get(userId);
  if (!user) {
    console.error("[updateUserStreak] User not found:", userId);
    throw new Error("User not found");
  }

  // CRITICAL: Capture UTC date ONCE to prevent midnight rollover race condition
  // between puzzle classification and streak calculation. If midnight occurs
  // between these calls, classification might use yesterday's date while
  // streak calculation uses today's date, causing incorrect streak updates.
  const today = getUTCDateString();

  // CRITICAL: Only update streak for today's daily puzzle
  // Archive/historical puzzle plays should NOT affect daily streak
  // Type-safe classification ensures this rule is enforced at compile time
  // Pass 'today' to ensure classification and calculation use same date reference
  const classification = classifyPuzzle(puzzleDate, today);

  if (!isDailyPuzzle(classification)) {
    console.warn("[updateUserStreak] Skipping streak update for archive puzzle:", {
      puzzleType: classification.type,
      puzzleDate: classification.date,
      userId,
    });
    return; // No streak update for archive puzzles
  }

  // Calculate streak update using explicit discriminated union
  const update = calculateStreakUpdate(
    user.lastCompletedDate || null,
    user.currentStreak,
    today,
    hasWon,
  );

  // Log update for debugging
  console.warn("[updateUserStreak] Calculated update:", {
    userId,
    updateType: update.type,
    reason: update.reason,
    currentStreak: user.currentStreak,
  });

  // Handle no-change case explicitly (same-day replay)
  if (update.type === "no-change") {
    console.warn("[updateUserStreak] Same-day replay - preserving streak:", user.currentStreak);
    return; // No database update needed
  }

  // Apply the update to get new state
  const newState = applyStreakUpdate(
    {
      currentStreak: user.currentStreak,
      lastCompletedDate: user.lastCompletedDate || null,
    },
    update,
  );

  // Update database with new streak
  const longestStreak = Math.max(newState.currentStreak, user.longestStreak);

  await ctx.db.patch(userId, {
    currentStreak: newState.currentStreak,
    lastCompletedDate: newState.lastCompletedDate,
    longestStreak,
    updatedAt: Date.now(),
  });

  console.warn("[updateUserStreak] Updated user streak:", {
    userId,
    updateType: update.type,
    newStreak: newState.currentStreak,
    longestStreak,
  });
}
