import { DatabaseWriter, QueryCtx } from "../_generated/server";
import { Doc, Id } from "../_generated/dataModel";

/**
 * Puzzle Helpers - Database Operations for Puzzles
 *
 * Module: Shared database helpers for puzzle operations
 * Location: convex/lib/ (not code-generated by Convex)
 *
 * Exports:
 * - updatePuzzleStats: Update puzzle statistics after completion
 * - selectYearForPuzzle: Select a random year with sufficient events for puzzle generation
 */

/**
 * Fisher-Yates shuffle algorithm for true randomness
 *
 * The common `.sort(() => Math.random() - 0.5)` pattern has poor distribution
 * properties and is not truly random. Fisher-Yates provides uniform distribution.
 *
 * Algorithm:
 * - Start from the end of the array
 * - For each position, swap with a random position from 0 to current position
 * - This ensures each permutation is equally likely
 *
 * @param array - Array to shuffle (will be copied, original unchanged)
 * @returns New shuffled array
 */
function fisherYatesShuffle<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

/**
 * Update puzzle statistics after completion
 *
 * Calculates and updates aggregate statistics for a puzzle based on all completed plays.
 * Called by submitGuess mutation when a user completes a puzzle.
 *
 * Statistics calculated:
 * - playCount: Total number of completed plays
 * - avgGuesses: Average number of guesses across all completions (rounded to 1 decimal)
 *
 * Performance: O(n) where n = number of completed plays for the puzzle
 *
 * @param ctx - Database writer context
 * @param puzzleId - Puzzle ID to update statistics for
 */
export async function updatePuzzleStats(
  ctx: { db: DatabaseWriter },
  puzzleId: Id<"puzzles">,
): Promise<void> {
  // Get all completed plays for this puzzle
  const completedPlays = await ctx.db
    .query("plays")
    .withIndex("by_puzzle", (q) => q.eq("puzzleId", puzzleId))
    .filter((q) => q.neq(q.field("completedAt"), null))
    .collect();

  const playCount = completedPlays.length;
  if (playCount === 0) return;

  // Calculate average guesses
  const totalGuesses = completedPlays.reduce((sum: number, play) => sum + play.guesses.length, 0);
  const avgGuesses = totalGuesses / playCount;

  // Update puzzle with calculated statistics
  await ctx.db.patch(puzzleId, {
    playCount,
    avgGuesses: Math.round(avgGuesses * 10) / 10, // Round to 1 decimal
    updatedAt: Date.now(),
  });
}

/**
 * Selects a random year with 6+ unused events for puzzle generation.
 *
 * Algorithm:
 * 1. Query all unused events (puzzleId = undefined)
 * 2. Group by year and count available events
 * 3. Filter to years with 6+ events (minimum for puzzle)
 * 4. Randomly select one eligible year
 * 5. Return selected year with its events
 *
 * Module Value: Hides complex year selection algorithm behind simple interface.
 * Deep Module: 40 lines of implementation complexity â†’ 1 function call
 *
 * @param ctx - Database query context
 * @returns Selected year, its events, and availability count
 * @throws Error if no years have 6+ unused events
 */
export async function selectYearForPuzzle(ctx: QueryCtx): Promise<{
  year: number;
  events: Doc<"events">[];
  availableEvents: number;
}> {
  // Get all unused events from pool
  const unusedEvents = await ctx.db
    .query("events")
    .filter((q) => q.eq(q.field("puzzleId"), undefined))
    .collect();

  // Group by year and count available events per year
  const yearCounts = new Map<number, number>();
  for (const event of unusedEvents) {
    const count = yearCounts.get(event.year) || 0;
    yearCounts.set(event.year, count + 1);
  }

  // Filter to years with sufficient events (6 minimum for puzzle)
  const availableYears = Array.from(yearCounts.entries())
    .filter(([, count]) => count >= 6)
    .map(([year, count]) => ({ year, availableEvents: count }))
    .sort((a, b) => a.year - b.year);

  if (availableYears.length === 0) {
    throw new Error("No years available with enough unused events");
  }

  // Randomly select one eligible year
  const randomYear = availableYears[Math.floor(Math.random() * availableYears.length)];

  // Get all unused events for the selected year
  const yearEvents = await ctx.db
    .query("events")
    .withIndex("by_year", (q) => q.eq("year", randomYear.year))
    .filter((q) => q.eq(q.field("puzzleId"), undefined))
    .collect();

  // Randomly select 6 events from the year's available events
  // Using Fisher-Yates shuffle for proper randomness (uniform distribution)
  const shuffled = fisherYatesShuffle(yearEvents);
  const selectedEvents = shuffled.slice(0, 6);

  if (selectedEvents.length < 6) {
    throw new Error(`Not enough events for year ${randomYear.year}`);
  }

  return {
    year: randomYear.year,
    events: selectedEvents,
    availableEvents: randomYear.availableEvents,
  };
}
